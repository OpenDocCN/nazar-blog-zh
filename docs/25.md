# 按位运算符

> 原文:[http://web . archive . org/web/20220810161336/https://imran nazar . com/Bitwise-Operators](http://web.archive.org/web/20220810161336/https://imrannazar.com/Bitwise-Operators)

计算机处理二进制数。二进制系统允许在每位数的水平上进行一些很酷的操作；问题是，相对来说很少有人了解这些操作，因为乍一看它们似乎很复杂。这份文件将证明他们不是，真的。

为了快速浏览，我假设你知道什么是二进制编码系统，以及它是如何工作的；此外，我将假设您对二进制有一点熟悉。每个使用计算机的人，无论是上网、玩视频游戏，还是仅仅编辑 Word 文档，都会经历过二进制编码系统，因为这是所有计算机内部的工作方式。然而，要进行二进制操作，您需要对这个系统如何操作有一个稍微高级一点的概念。我还将展示使用 C 语言语法及其派生语法(C++、PHP、Java 等)的任何代码示例。如果您不知道操作符的 C 语法，也不用担心；我会在文档的末尾放一个小表格。

### 还有:戴上面具

要查看的第一个操作叫做 AND。之所以这样称呼它，是因为它确实是这样做的:接受两个输入，只有当输入 1 和输入 2 都打开时才返回任何输出。

| in1 | in2 | in1 和 in2 |
| --- | --- | --- |
| Zero | Zero | Zero |
| Zero | one | Zero |
| one | Zero | Zero |
| one | one | one |

该表是*真值表*的一个例子；它画出了所有可能的输入组合，以及操作员将对它们做什么。正如您所看到的，只有当两个输入都为 1 时，AND 运算符才返回 1。但是对于大于一位的数字，这在现实世界中对我们有什么帮助呢？

### 使用和来屏蔽值

可以做的主要事情是*屏蔽*:只使用你想用的那部分数字。例如，假设你有一个 32 位变量，你在一个循环中递增它。但是你想把 255 之后的值包装回 0。你可能会想，这是一个使用`if`语句的简单例子。但是再想想。

#### 和:屏蔽 32 位值

```
while(1)
{
    i++;
    // How we'd do this with an if clause
    // if(i > 255) i = 0;

    // How to do it with AND
    i = i & 255;
}
```

这里发生了什么事？我们先来看一个正常的案例；假设`i`的值为 77。AND 运算看起来像这样:

#### 和:i=72 时的掩蔽

```
00000000 00000000 00000000 01001101
00000000 00000000 00000000 11111111   [AND]
-----------------------------------
00000000 00000000 00000000 01001101
```

“与”掩码实质上是通过`i`的低 8 位进入结果。在这种情况下，77 正好适合 8 位，所以没有变化。在临界情况下会发生什么:当 255 变成 256 时？

#### 和:i=256 时的掩蔽

```
00000000 00000000 00000001 00000000
00000000 00000000 00000000 11111111   [AND]
-----------------------------------
00000000 00000000 00000000 00000000
```

如上所述，`i`的低 8 位正在通过。那就是 0。该值的其余部分，包括“256”位，基本上被掩码忽略，这意味着该值自动从 255 换行到 0。很有用，你得承认。

### 和在 IP 寻址中的作用

你可以做的另一件事是清除一个值的某一部分。例如，您想要检查 IP 地址所在的网络。IP 地址只是另一个 32 位的数字，伴随它的子网掩码就是:使用 and 运算符应用于 IP 的掩码，用于查找该 IP 地址的子网。

让我们把我的装置带回家。我家里有几台电脑，都有一个私有 IP 范围内的地址。其中一台计算机是`172.16.55.37`，子网掩码为`255.255.255.224`；路由器怎么知道我来自哪个网络？

#### 还有:你在哪个子网？

```
IP address: 10101100.00010000.00110111.00100101
Snet Mask:  11111111.11111111.11111111.11100000
AND:        -----------------------------------
Subnet:     10101100.00010000.00110111.00100000  [172.16.55.32]
```

因此，当路由器看到目的地为 172.16.55.37 的数据包时，它会应用“与”运算，计算出该网络在其路由表中，然后转发该数据包。换句话说，没有 AND 运算符，互联网就无法工作。

### 用来清理一点

AND 的最后一个例子:当你想创建一个 Windows 应用程序时，你通常想显示一个窗口，而窗口可以有各种各样的样式与之相关联。最常用的样式是`WS_OVERLAPPEDWINDOW`，它只是一个数字，有一个更容易阅读的名字:它结合了各种样式，告诉 Windows 提供标题、系统菜单、最小化和最大化按钮。

但是如果你不想要最小化按钮呢？你可以选择普通的样式，然后去掉`WS_MINIMIZEBOX`的值。设置样式值时考虑的就是这个想法:简单样式是二进制幂值，复杂样式将它们组合在一起。

所以让我们试一下:一个没有最小化按钮的窗口。

#### 和:清除一点

```
OVERLAPPEDWINDOW:  00000000 11001111 00000000 00000000
MINIMIZEBOX:      (00000000 00000010 00000000 00000000)
Clear mask:        11111111 11111101 11111111 11111111
AND:               -----------------------------------
Overall style:     00000000 11001101 00000000 00000000
```

如果新值被传递给 Windows，你会得到一个闪亮的新窗口，没有最小化按钮。要生成透明遮罩，您可以使用 NOT 操作符，我们稍后将会用到它。

### 或者:设置位

我们要研究的第二个操作符叫做 or。正如你所猜测的，它被称为 OR 是有原因的:它接受两个输入，如果设置了其中一个或另一个，或者两个都设置了，就给出一个输出。这是另一个真值表。

| in1 | in2 | in1 或 in2 |
| --- | --- | --- |
| Zero | Zero | Zero |
| Zero | one | one |
| one | Zero | one |
| one | one | one |

注意`in1`是开还是关并不重要；如果`in2`开启，则结果开启。当然，反之亦然。那么，如何在现实世界中使用它呢？

or 的主要应用是设置位；用 1 填充一个值的一部分。让我们看看上面的窗口样式:你可能不仅想要一个普通的窗口，还想要一个可以处理内容垂直滚动的窗口。幸运的是，定义这样一个窗口很简单:只需将`WS_OVERLAPPEDWINDOW`默认样式和`WS_VSCROLL`固定在一起。

#### 或者:填入一个值

```
OVERLAPPEDWINDOW:  00000000 11001111 00000000 00000000
VSCROLL:           00000000 00100000 00000000 00000000
OR together:       -----------------------------------
New window style:  00000000 11101111 00000000 00000000
```

通过以这种方式使用 AND 和 OR，很容易就可以构建出你想要的窗口样式。

### 异或:或与一个扭曲

或者是允许您在两个输入中的一个或两个都设置时设置一个位的操作。但是，如果您只想检查其中一项，而不是两项都检查，该怎么办呢？有一个操作符，叫做异或，简称 XOR。给你另一个真值表:

| in1 | in2 | in1 异或 in2 |
| --- | --- | --- |
| Zero | Zero | Zero |
| Zero | one | one |
| one | Zero | one |
| one | one | Zero |

现在，让一个操作符只设置任一个输入，而不是两个都设置，这似乎有点深奥和理论化。然而，XOR 运算确实很有用。

### 异或以清除一个值

如果你有一个变量或者一个 CPU 寄存器，你想把它清零，你不关心里面是什么；那些内容无论如何都会被抹去。当然，您可以简单地将“0”移动到该变量中，但是在某些情况下，这可能是一个问题。相反，您可以使用 XOR。

#### XOR:清零

```
Random value: 11001001 01001110 11010010 11110001
Value again:  11001001 01001110 11010010 11110001
XOR:          -----------------------------------
Output:       00000000 00000000 00000000 00000000
```

对于该示例中的 32 位中的每一位，真值表的顶部或底部行匹配，这意味着两种情况下的输出都是 0。当然，最终结果是，在 XOR 运算之后，该值的所有位都变成 0。为什么会有人想要做这样的手术呢？看看这个例子，在英特尔汇编。

#### XOR:程序集用法

```
mov eax, 0       ; Assembles to 5 bytes
xor eax, eax     ; Assembles to 1 byte
```

如果你很看重空间，很明显你会选择这两个中的哪一个；按位运算符可以做同样的工作，而不是浪费 4 个字节的空间。

### 异或来翻转一位

XOR 的另一个主要应用是翻转一个值内的一位或一系列位。如果你看一看两半的真值表，上半部分本质上是下半部分颠倒过来的；并且翻转由`in1`的值控制。这在某些情况下非常有用。

例如，假设你的任务是产生一个方波:一系列恒定的脉冲，64，191，64，191。您可以实现一系列复杂的`if`语句，也可以使用简单的 XOR。

#### XOR:产生 1kHz 方波

```
char output = 64;
while(1)
{
    output = output ^ 255;
    usleep(500);    // sleep for half the wave period
}
```

那么，这里发生了什么？输出值从 64 开始，每次循环运行时，XOR 都会改变输出值。这种变化是如何体现的？

#### XOR:将方波发送至高电平

```
output: 01000000
Mask:   11111111
XOR:    --------
Result: 10111111
```

所以我们从 64 开始，XOR 将所有位翻转到 191。500 毫秒后，重新进入循环，并再次应用 XOR:

#### XOR:发送相同的波低

```
output: 10111111
Mask:   11111111
XOR:    --------
Result: 01000000
```

就像变魔术一样，XOR 返回我们第一次输入的结果:191 变成 64。因为 500 微秒的值是 64，另外 500 微秒的值是 191，所以总的波形周期是 1 毫秒，我们只用一次 XOR 运算就产生了 1kHz 方波。

### 不是:一元的

如果你想做的只是翻转整个值，就像上面的例子一样，还有一个选择。它被称为 NOT，它不同于我们到目前为止讨论过的其他位操作符。不是取两个输入，只是取一个；输出与输入相反。

| x | 不是 x |
| --- | --- |
| Zero | one |
| one | Zero |

没有什么是那些更深奥操作之一；看不出有多大用处。它可以产生良好效果的一个地方是生成用于 AND 操作的掩码。假设您想要屏蔽掉一个值的所有位，除了底部的两位。我们可以让按位运算符替我们完成繁重的工作，而不用纠结于二进制或十六进制的长字符串。

#### 不:生成 AND 掩码

```
value = value & (~3);
```

好吧。简短，简洁，但它在做什么？我们来看看二进制层面。

#### 不是:世代是如何发生的

```
Three:  00000000 00000000 00000000 00000011
NOT 3:  11111111 11111111 11111111 11111100
Value:  11001001 00011110 10001101 00111011
AND:    -----------------------------------
Result: 11001001 00011110 10001101 00111000
```

这样，你可以很容易地生成你的 AND 运算所需要的掩码，而不必深究十六进制字符串，也不必记住任何组合表；没有人为你做艰苦的工作。

### 轮班:洗牌

到目前为止，按位运算符都是 1 位事务:从输入中取出一位(或两位)，给出一位输出。然而，有一些运算符采用一整串二进制数字，并对其进行简单的运算。这些运算符的主要例子是 shift。

换档有两种方式:向左和向右。正如你可能猜到的，左移是取一个二进制值串，并将其左移，将其提升二进制幂。我们来看一个例子。

#### 左移:向上推动一个值

```
Before: 00001111
Left 1: 00011110
Left 2: 00111100
Left 3: 01111000
```

1 从值的底部被向上推到顶部；剩下的空白用 0 来填充。如果你仔细观察，你会发现这实质上相当于将值乘以 2 的幂:在移位之前，我们有 15。左移 1，我们得到 30；左移 2 得到 60，左移 3 得到 120。

然而，如果我们从顶部附近的 1 开始，然后开始左移，会发生什么呢？让我们来看看。

#### 左移:比特桶

```
Before: 01100101
Left 1: 11001010
Left 2: 10010100
Left 3: 00101000
```

值果然发生了变化，在底部插入了 0，但是上面的 1 去哪里了呢？答案是，他们消失了；基本上，由于移位操作，它们脱离了值的末端。如果您决定使用移位，请记住，如果您用完了位的空间，就会发生这种情况。

还要注意最高有效位在连续移位操作中是如何变化的。如果你在处理有符号的值，最高有效位通常用来表示符号(1 表示这是一个负数)；在这种情况下，你的数字是从正到负，然后再回到正！这是移位操作的一个缺点，当你使用它时必须记住。

右移与左移非常相似，只是它的作用方向相反:位向右移动，0 从左边插入。

#### 右移:向下推

```
Before:  00111000
Right 1: 00011100
Right 2: 00001110
Right 3: 00000111
```

正如左移可以被认为是乘以二进制幂一样，右移可以被用来除以二进制幂；在上面的例子中，56 变成了 28，然后是 14，然后是 7，简单地通过连续向右移位。

就像左移一样，如果 1 在范围的低端，右移也不能提供保护。在上面的例子中，另一次右移将产生值 3，因为最低的 1 只是从值的末尾消失。

就像左移一样，最高位没有安全措施；如果它从 1 开始(在有符号的值中表示负的)，右移将填充 0，使值为正。因此，处理器和编程语言通常提供“算术”右移操作，如果高位为 0，则用 0 填充，如果高位为 1，则用 1 填充；通过使用算术右移，保留了值的符号。

这很好，在二进制字符串中传递值。但是它能达到什么目的呢？在现实世界中如何使用班次？

### 移位以合并值

假设您拥有四个 8 位值，并且您希望通过将它们组合在一起来构建一个 32 位值。左移使得这个任务非常容易完成。

#### 左移:建立价值

```
Values: 11001010, 00111010, 01001101, 00110011
Pushing all values into 32-bit variables:

var4:  00000000 00000000 00000000 00110011
var3:  00000000 00000000 01001101 00000000  <-- left shift 8
var2:  00000000 00111010 00000000 00000000  <-- left shift 16
var1:  11001010 00000000 00000000 00000000  <-- left shift 24
OR:    -----------------------------------
Final: 11001010 00111010 01001101 00110011

value = var4 | (var3 << 8) | (var2 << 16) | (var1 << 24);
```

类似地，如果您想将 32 位的值分割成 8 位的块，您可以简单地执行一个连续的右移 8 位的操作，结合一个 AND 操作来屏蔽您要寻找的结果部分。

#### 右移:拆分值

```
Initial: 11001010 00111010 01001101 00110011
Mask:    00000000 00000000 00000000 11111111
AND:     -----------------------------------
var4:                               00110011

RShift:  00000000 11001010 00111010 01001101
Mask:    00000000 00000000 00000000 11111111
AND:     -----------------------------------
var3:                               01001101

RShift:  00000000 00000000 11001010 00111010
Mask:    00000000 00000000 00000000 11111111
AND:     -----------------------------------
var2:                               00111010

RShift:  00000000 00000000 00000000 11001010
Mask:    00000000 00000000 00000000 11111111
AND:     -----------------------------------
var1:                               11001010

var4 = value & 255;
var3 = (value >> 8) & 255;
var2 = (value >> 16) & 255;
var1 = (value >> 24) & 255;
```

有点罗嗦，至少在用原始二进制写下来的时候。不过，请记住，计算机可以以愚蠢的高速度完成这项工作，尤其是当你使用的是为处理比特而设计的运算符时。

### 用于相乘的移位

移位的另一个用途是将值乘以不是直接二进制幂的乘数。这不再是一个常见的操作，因为现在乘法单元非常快，但是如果你曾经在一些旧代码中遇到一个奇怪的移位操作序列，你会知道它在做什么，为什么会在那里。

在过去的 VGA 时代，PC 上最常用的图形模式是 320 像素一行。像素以平面帧缓冲区的形式写入屏幕:直接转换到屏幕的内存部分，320 字节一行。这意味着在内存中找出一个位置，给定一个 X 和 Y 坐标来绘制。这个公式非常简单，但是当时 CPU 的乘法单元非常慢，所以每个优势都被挖掘出来。

#### 左移:乘以 320

```
Memory Location = (y * 320) + x
                = (y * 256) + (y * 64) + x
		= (y << 8) + (y << 6) + x
```

因为移位比乘法快几个数量级，所以这一系列的两次移位和两次加法比一次乘法和一次加法快得多。当然，您可能不会再经常看到这种情况，因为 CPU 实际上擅长乘法，但您可能会在其他地方遇到这种技术。

### 结束了

这就是你在编程过程中遇到的所有位运算子。有些可能非常有用，有些可能不常用，但毫无疑问:它们总有一天会被用到。

最后一点:这个表显示了 C-syntax 语言是如何表示按位运算符的。

| 操作员 | 标志 | 句法 |
| --- | --- | --- |
| 和 | &的记号名称 | x & y |
| 运筹学 | 立管 | x &#124; y |
| 异或运算 | 脱字号 | x ^ y |
| 不 | 波浪号 | ~ x |
| 左移 | 两个小于号 | x << y |
| 右移 | 两个大于号 | x >> y |

由 Imran Nazar 于 2006 年公布于众。

文章日期:2006 年 9 月 22 日